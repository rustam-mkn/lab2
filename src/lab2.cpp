#include "mystring.hpp"
#include "BaseFile.hpp"
#include "Base32File.hpp"
#include "RleFile.hpp"
#include "function.hpp"
#include <iostream>

// make clean && make debug

/**
 * Лабораторная работа №2. Массивы объектов, простое наследование, виртуальные
 * функции, применение наследования.
 *
 * В этой работе и далее предполагается, что вы будете использовать классы,
 * написанные в прошлых работах, и дополнять их по необходимости. Эти классы
 * будут называться по имени без дополнительных указаний, что их надо взять из
 * прошлой работы.
 *
 * Предполагается, что новый классы будут созданы по аналогии с предыдущими
 * работами в отдельных файлах, которые будут включены в сборку.
 *
 * При работе с классами - в учебных целях - нельзя пользоваться контейнерами
 * стандартной библиотеки и нужно следовать принципам инкапсуляции.
 */


int main() {
    /**
     * Задание 1. Массивы объектов класса.
     */

    /**
     * Задание 1.1. Массив объектов.
     *
     * Объявите и проинициализируйте массив ar из объектов типа MyString.
     * Выведите элементы массива на консоль.
     */
    /**
     * Замените размер массива с 3 на 5, не меняя список инициализаторов.
     *
     * Чем были инициализированы последние 2 элемента? Какие значения могут
     * стоять в списке инициализаторов - в вашем случае и в общем случае?
     */

    line();
    {
        MyString ar[5] = { "deep", "learning", "school" }; // размер 5 но инициализирован 3
        for (int i = 0; i < 5; ++i) {
            ar[i].print();
        }
    }
    /*  [0] MyString("deep")
        [1] MyString("learning"), 
        [2] MyString("school") --- созданы конструктором MyString(const char *str), который выделяет память и копирует строку
        
        [3] MyString() - (empty)
        [4] MyString() - (empty)
        созданы конструктором по умолчанию data = nullptr и length = 0
    */
   line();


    /**
     * Задание 1.2. Массив указателей на объекты.
     *
     * Объявите и проинициализируйте массив arPtr из трех указателей на объекты
     * типа MyString. Выведите элементы массива на консоль.
     */

    
    MyString* arPtr[3] = { new MyString("one"), new MyString("two"), new MyString("thr") };

    for (int i = 0; i < 3; ++i) {
        std::cout << "arPtr[" << i << "] = " << arPtr[i] << "\t";   // вывод неразыменованного массива укаазтелей
        (*arPtr[i]).print();                                        // вывод разыменованного массива укаазтелей
    }
    
    for (int i = 0; i < 3; ++i) {delete arPtr[i];} // delete
    line();

    /**
     * Задание 2. Простое наследование. Аргументы конструктора, передаваемые в
     * базовый класс.
     */

    /**
     * Задание 2.1. Базовый класс.
     *
     * Создайте класс BaseFile, который будет реализовывать работу с файлами с
     * помощью стандартных средств C (cstdio).
     *
     * Класс должен иметь 3 конструктора: первый - конструктор по умолчанию,
     * второй должен принимать путь к файлу и параметры для открытия (как в
     * fopen), третий должен принимать готовый указатель FILE*.
     *
     * Считается, что этот класс *обладает* своим ресурсом - открытым файлом.
     * Что должно быть в дестукторе этого класса?
     *
     * Добавьте следующие методы:
     * - bool is_open() - возвращает true, если файл успешно открыт;
     * - bool can_read() - возвращает true, если из файла можно считать данные;
     * - bool can_write() - возвращает true, если в файл можно записать данные;
     * - size_t write_raw(const void *buf, size_t n_bytes) - записывает
     *   указанное количество байт в файл и возвращает количество байт, которое
     *   удалось записать;
     * - size_t read_raw(void *buf, size_t max_bytes) - читает доступные данные
     *   в буфер, но не более указанного количества и возвращает количество
     *   байт, которое удалось считать;
     * - long tell() - возвращает текущий сдвиг файла (см. функцию ftell);
     * - bool seek(long offset) - устанавливает сдвиг файла (см. функцию fseek)
     *   и возвращает true, если операция успешна.
     *
     * Добавьте также методы `read` и `write`, которые в этом классе будут
     * делать буквально то же, что `read_raw` и `write_raw`, они понадобятся нам
     * позже.
     *
     * Проверьте работу этого класса.
     */
    std::cout << "꒰ᐢ..ᐢ꒱₊˚⊹ Тестируем BaseFile" << std::endl;

    BaseFile file1("text/BaseFile_file1.txt", "w+");

    if (file1.is_open() == false) {
        std::cerr << "err, файл не отрылся" << std::endl;
    }
    std::cout << "Файл успешно открыт!" << std::endl;


    // запись  
    const char* text = "Pokemon!";
    size_t w = file1.write_raw(text, strlen(text));

    std::cout << "Записано " << w << " байт" << std::endl;


    // перемещение в начало --- seek и tell  
    if (file1.seek(0)) {std::cout << "Переместились в начало файла!" << std::endl;}
    std::cout << "Текущая позиция: " << file1.tell() << std::endl;


    // считываем
    if (file1.can_read() == false) {
        std::cerr << "err, файл не прочитан" << std::endl;
    } else {
        std::cout << "Файл успешно прочитан!" << std::endl;
    }

    char buffer[50] = {0};
    //size_t r = file1.read_raw(buffer, strlen(text));
    std::cout << "Содержимое файла --- " << buffer << std::endl;

    


    /**
     * Задание 2.2. Производные классы.
     *
     * Производный класс *наследуется* от базового класса и каким-то образом
     * расширяет его функциональность, при это все еще умея все, что умеет
     * базовый класс.
     *
     * Реализуйте следующие производные классы от класса BaseFile. Производные
     * классы нужно унаследовать так, чтобы пользователю были все еще доступны
     * методы базового класса. Каким образом нужно унаследовать класс для этого?
     * Как еще можно унаследовать класс?
     *
     * Производные классы могут располагаться в том же файле, где и базовый
     * класс.
     *
     * В производных классах добавьте необходимые конструкторы, которые будут
     * вызывать конструктор базового класса.
     *
     * Проверьте работу производных классов.
     */

    // вместо file.write_raw("Hello!", strlen("Hello!"));
    //        file.write_text("Hello!"); в наследованном классе

    // C-строка — это массив символов с нулевым символом (\0) в конце
    line();

    newText texttt(file1);
    
    bool check = texttt.write_text("Hello!");
    if (check) {std::cout << "Запись успешна!" << std::endl;
    } else {std::cerr << "Ошибка записи!" << std::endl;}

    texttt.seek(0);

    bool ckeck2 = texttt.read_text(buffer, sizeof(buffer) - 1);
    if (ckeck2) {std::cout << "Содержимое файла --- " << buffer << std::endl;
    } else {std::cerr << "Ошибка чтения!" << std::endl;}

    //file1.close();
    

    /**
     * Задание 2.2.1. Base32 кодировщик/декодировщик.
     *
     * Создайте производный класс Base32File, который будет проводить при
     * записи кодировку-декодировку данных, по алгоритму, который вы
     * реализовали в лабораторной работе №4 прошлого семестра.
     *
     * Переопределите методы `read` и `write`, которые будут проводить чтение из
     * файла с декодировкой и запись в файл с кодировкой соответственно.
     *
     * Добавьте возможность пользователю передать в конструктор таблицу
     * кодировки, по умолчанию используется таблица "A..Z1..6".
     */

    
    line();
    std::cout << strlen("ABCDEFGHIJKLMNOPQRSTUVWXYZ123456") << std::endl;
    
    BaseFile file2("text/BaseFile_file2.txt", "w+");
    Base32File base32File(file2);

    const char* text2 = "Berlin";
    std::cout << "Исходная строка: " << text2 << std::endl;


    // выделяем буфер
    char encodedBuffer[1024];  
    char decodedBuffer[256] = {0};


    // Кодируем текст в Base32
    size_t encodedSize = 0;
    base32File.encode(text2, strlen(text2), encodedBuffer, encodedSize);
    std::cout << "Закодированный текст: " << encodedBuffer << std::endl;



    // Запись закодированного текста
    if (base32File.write(text2, strlen(text2))) {
        std::cout << "Запись в Base32 успешна!" << std::endl;
    } else {
        std::cerr << "Ошибка при записи в Base32!" << std::endl;
    }


    // сброс позиции чтения
    base32File.seek(0);





    // чтение и декодирование
    if (base32File.read(decodedBuffer, sizeof(decodedBuffer) - 1)) {
        std::cout << "Декодированное содержимое: " << decodedBuffer << std::endl;
        if (strcmp(text2, decodedBuffer) == 0) {
            std::cout << "Исходные и декодированные данные совпадают" << std::endl;
        } else {
            std::cerr << "Ошибка: Декодированные данные не совпадают с исходными!" << std::endl;
        }
    } else {
        std::cerr << "Ошибка при чтении из Base32!" << std::endl;
    }
    

    //file2.close();

    



    /**
     * Задание 2.2.2. RLE-сжатие.
     *
     * Создайте производный класс RleFile, который будет проводить побайтовое
     * сжатие при помощи алгоримта RLE (для простоты можно реализовать
     * неэффективный алгоритм, где последовательности без повторений отдельно
     * не кодируются).
     *
     * Переопределите методы `read` и `write`, которые будут проводить чтение из
     * файла с извлечением сжатой информации и запись в файл со сжатием
     * соответственно.
     *
     * Проверьте сжатие/извлечение на примере какого-нибудь ASCII-арта,
     * например, котенка из лабораторной №3 прошлого семестра. Посмотрите,
     * получилось ли добиться уменьшения размера хранимых данных.
     */
    line();
    const char* input = "AAAAABBBCCDDDDDEEEEEEEEE";
    std::cout << "input: " << input << std::endl;

    RleFile file3("text/RleFile_file3.txt", "w+");

    // Запись сжатых данных
    //size_t written = file3.write(input, strlen(input));

    file3.seek(0); // в начало

    char decoded[256] = {0};
    file3.read(decoded, sizeof(decoded));

    std::cout << "Востановленный текст: \n" << decoded << std::endl;
    //file3.close();


    /**
     * Задание 2.3. Конструкторы и деструкторы базового и производного классов.
     *
     * Установите отладочную печать в конструкторах и деструкторах каждого
     * класса из этого задания. Создайте локальные объекты производных классов,
     * отметьте, в каком порядке вызываются конструкторы и деструкторы при
     * инициализации и деинициализации этих классов.
     */
    line();
    std::cout << "=== Создание объекта BaseFile ===\n";
    BaseFile file4("text/BaseFile_file4.txt", "w+");

    std::cout << "\n=== Создание объекта newText ===\n";
    newText file5("text/newText_file5.txt", "w+");

    std::cout << "\n=== Конец программы ===\n";


    // закрытие file1 и file2 выполняется в нескольких местах


    /*
BaseFile file1("text/BaseFile_file1.txt", "w+");
BaseFile file2("text/BaseFile_file2.txt", "w+");
BaseFile file4("text/BaseFile_file4.txt", "w+");
newText texttt(file1); (работает с file1)
newText file5("text/newText_file5.txt", "w+");
Base32File base32File(file2); (работает с file2)
RleFile file3("text/RleFile_file3.txt", "w+");
    */    



    /**
     * Задание 2.4. Ранее связывание.
     *
     * На основе данной заготовки напишите код, который запишет в файл строковое
     * представление целого числа. Вы должны использовать один и тот же код для
     * всех файлов, меняя только имя объекта (bf / b32f / rf), в который идет
     * запись.
     */
    line();
    
    BaseFile    bf  ("text/BaseFile_file6.txt", "w+");
    Base32File b32f ("text/Base32File_file7.txt", "w+");
    RleFile     rf  ("text/RleFile_file8.txt", "w+");
    

    /**
     * Задание 2.5. Передача объекта по ссылке / указателю.
     *
     * Прошлое задание выглядит странновато - зачем повторять код три раза?
     * Хорошо бы сделать функцию, которая примет объект файла и число, и
     * выполнит эти действия.
     *
     * Реализуйте функцию `write_int(BaseFile &file, int n)`, которая будет
     * принимать ссылку на файл и число, которое нужно будет напечатать.
     *
     * Принцип наследования предписывает, что везде, где можно использовать
     * базовый класс, можно использовать производный класс. Проверьте, можно
     * ли вызвать функцию, передав в нее объект класса Base32File и RleFile.     ---     можно
     *
     * Имеет ли вызов этой функции для производного класса тот же результат,
     * что и код, который вы написали выше? Почему?
     */
    line();
    
    int n = 123456;

    write_int(bf, n);
    write_int(b32f, n);
    write_int(rf, n);

    bf.seek(0);
    b32f.seek(0);
    rf.seek(0);

    // Открываем файлы для чтения
    BaseFile    bf_r  ("text/BaseFile_file6.txt", "r");
    Base32File b32f_r ("text/Base32File_file7.txt", "r");
    RleFile     rf_r  ("text/RleFile_file8.txt", "r");

    // Читаем и печатаем числа из файлов
    read_int(bf_r);
    read_int(b32f_r);
    read_int(rf_r);
    
    line();



    /**
     * Задание 2.6. Виртуальные функции, позднее связывание.
     *
     * Объявите функции read и write в базовом классе *виртуальными*. Что это
     * означает? Как изменился размер объектов классов BaseFile, Base32File и
     * RleFile? Почему?
     *
     * Как изменилось поведение при вызове функции `write_int` для производных
     * классов? Почему?
    
     virtual - разрешение на переопределение в наследственном классе
  
    
        |A get():int|           базовый класс
     (A)|B get():int|           наследственный от A класс B

     когда мы вызываем: A a.get() вызывается метод из A
     когда мы вызываем: B b.get() вызывается метод из B

    программа:
    f(A a);   Создание. Функция ожидает объект A
    B b;
    f(b)


    - - - - - Раннее связывние
    class A {int get(); return 1;}  базовый класс
    class B {int get(); return 2;}  наследственный от A класс B

    void f(A a) {a.get();}      Создание. Функция ожидает объект A
    передача по значению
    
    B b;
    f(b);   результат 1
    вызовется A::get(), даже если передали B
    компилятор видит что функция ожидает [A a] -> вызывается метод из A -> a.get()




    
    - - - - - Позднее связывание
    class A {   virtual    int get(); return 1;}  базовый класс
    class B {   override   int get(); return 2;}  наследственный от A класс B   

    void f(A &a) {a.get();}     Создание. Функция ожидает объект A
    передача по ссылке

    B b;
    f(b);  результат 2
    вызовется B::get(), если передали B
    компилятор видит что функция ожидает [A a] -> видит virtual -> находит override у B -> вызывается метод из B -> b.get()
     */
    
    



    /**
     * Задание 2.7. Виртуальный деструктор.
     *
     * В следующем блоке кода добавьте удаление динамической памяти.
     *
     * Какой деструктор при этом вызывается? Почему? К каким проблемам это может
     * привести?
     * Исправьте эту ситуацию.
     * 
     * 
     * 
если BaseFile::~BaseFile() НЕ виртуальный:
вызывается только BaseFile::~BaseFile() для всех объектов
Деструкторы RleFile и Base32File не вызываются == утечка

если BaseFile::~BaseFile() виртуальный:
вызывается корректный деструктор каждого класса:
            Base32File::~Base32File()
            RleFile::~RleFile()
            BaseFile::~BaseFile() */
    line();
    {
        BaseFile *files[] = { 
            new BaseFile("text/BaseFile_file9.txt", "w"), 
            new RleFile("text/RleFile_file10.txt", "w"), 
            new Base32File("text/Base32File_file11.txt", "w"), 
        };

        for (int i = 0; i < 3; ++i) {
            files[i]->write("Hello!", 6);
        }

        for (int i = 0; i < 3; ++i) {delete files[i];}
    }

    /**
     * Задание 2.8. Массив объектов производных классов.
     *
     * Раскомментируйте следующий блок и объясните, почему:
     * а) не возникает ошибок при компиляции;
компилятор разрешает приведение Base32File[] к BaseFile*, потому что Base32File унаследован от BaseFile


     * б) возникают ошибки при выполнении.
массив Base32File[2] воспринимается как BaseFile[2], теряются данные производного класса
     *
     * Этот пример показывает очень плохую практику, которая приводит к ошибкам;
     * для создания массива объектов производного класса и используйте массив
     * указателей на базовый класс, как это было сделано выше. Реализуйте ту же
     * логику, используя массив указателей на объекты базового класса.
    

Base32File[2], компилятор выделяет память для двух объектов Base32File

при создании массива объектов с использованием new[] для производных классов (Base32File)
компилятор пытается создать объекты типа BaseFile для массива, а не объекты типа Base32File

массив создаёт массив объектов типа BaseFile, но пытается инициализировать его объектами типа Base32File
это приводит к срезанию данных




     */

    // {
    //     BaseFile *base_files = new BaseFile[2] { BaseFile("text/BaseFile_file12.txt", "w"), BaseFile("text/BaseFile_file13.txt", "w") };
    //     BaseFile *b32_files = new Base32File[2] { Base32File("text/Base32File_file14.txt", "w"), Base32File("text/Base32File_file15.txt", "w") };
    //     for (int i = 0; i < 2; ++i) {
    //         base_files[i].write("Hello!", 6);
    //         b32_files[i].write("Hello!", 6);
    //     }
    //     delete [] base_files;
    //     delete [] b32_files;
    // }

    {
        // Массив указателей на объекты базового класса
        BaseFile* base_files[2] = {
            new BaseFile("text/BaseFile_file12.txt", "w"),
            new BaseFile("text/BaseFile_file13.txt", "w")
        };
        
        BaseFile* b32_files[2] = {
            new Base32File("text/Base32File_file14.txt", "w"),
            new Base32File("text/Base32File_file15.txt", "w")
        };
    
        // Запись данных в файлы
        for (int i = 0; i < 2; ++i) {
            base_files[i]->write("Hello!", 6);
            b32_files[i]->write("Hello!", 6);
        }
    
        // Очистка памяти
        for (int i = 0; i < 2; ++i) {
            delete base_files[i];
            delete b32_files[i];
        }
    }

    return 0;
}
